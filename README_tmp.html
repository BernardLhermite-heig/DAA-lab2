<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="d%C3%A9veloppement-android">Développement Android</h1>
<h2 id="laboratoire-n%C2%B02-interactions-avec-lutilisateur---approche-mvc">Laboratoire n°2: Interactions avec l’utilisateur - Approche MVC</h2>
<h3 id="friedli-jonathan-marengo-st%C3%A9phane-silvestri-g%C3%A9raud">Friedli Jonathan, Marengo Stéphane, Silvestri Géraud</h3>
<h3 id="15112022">15.11.2022</h3>
<h2 id="introduction">Introduction</h2>
<p>Le but de ce laboratoire est de réaliser une
activité proposant un formulaire permettant d’éditer les informations d’une personne. Ledit formulaire est décomposé en plusieurs parties et devra s'adapter à la saisie d'un étudiant ou d'un travailleur en affichant uniquement les parties pertinentes.</p>
<h2 id="1-d%C3%A9tails-dimpl%C3%A9nentation">1. Détails d'implénentation</h2>
<h3 id="11-layout">1.1. Layout</h3>
<p>Nous avons réussi à faire toute notre interface graphique à l'aide d'un seul <code>constraint layout</code>. Nous avons regroupé les différents champs dans plusieurs groupes: <code>group_base</code> contient toutes les informations principales comme le nom, la date de naissance et les <code>radio button</code> permettant de choisir entre un étudiant et un employé.</p>
<p>Le groupe <code>group_student</code> contient toutes les informations relatives à un étudiant comme l'université et l'année de la filière. Ce groupe n'est visible que si le <code>radio button</code> &quot;étudiant&quot; est coché.</p>
<p>Le groupe <code>group_worker</code> contient toutes les informations relatives à un employé comme son entreprise, son secteur et son expérience. Comme précédemment, ce groupe n'est visible que si le <code>radio button</code> &quot;employé&quot; est coché.</p>
<p>Finalement nous avons un dernier groupe qui est tout le temps affiché: <code>group_additional</code> qui contient les informations supplémentaires comme l'adresse mail et un champ pour faire des commentaires.</p>
<p>Il est important de noter que les groupes <code>group_base</code> et <code>group_additional</code> ne sont pas utiles mais nous les avons mis afin d'être cohérent.</p>
<p>Voici le code qui permet de les masquer/afficher:</p>
<pre class="hljs"><code><div>radGroup.setOnCheckedChangeListener { _, checkedId -&gt;
    <span class="hljs-keyword">when</span> (checkedId) {
        R.id.main_occupation_student -&gt; {
            workerGroup.visibility = View.GONE
            studentGroup.visibility = View.VISIBLE
        }
        R.id.main_occupation_worker -&gt; {
            workerGroup.visibility = View.VISIBLE
            studentGroup.visibility = View.GONE
        }
        <span class="hljs-keyword">else</span> -&gt; {
            workerGroup.visibility = View.GONE
            studentGroup.visibility = View.GONE
        }
    }
}
</div></code></pre>
<h3 id="12-scrollview">1.2. ScrollView</h3>
<p>Nous avons mis tout notre layout dans une scrollview afin de voir toutes les informations lorsque le clavier est ouvert.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">ScrollView</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span>
    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">"http://schemas.android.com/tools"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">".MainActivity"</span>&gt;</span>


     <span class="hljs-comment">&lt;!-- layout --&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">ScrollView</span>&gt;</span>
</div></code></pre>
<h3 id="13-barri%C3%A8re">1.3. Barrière</h3>
<p>Nous avons utilisé une barrière afin de faire en sorte que toutes les <code>EditText</code> soit alignées. Pour ce faire, nous avons rajouter une balise <code>androidx.constraintlayout.widget.Barrier</code></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.Barrier</span>
            <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/main_barrier"</span>
            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
            <span class="hljs-attr">app:barrierDirection</span>=<span class="hljs-string">"end"</span>
            <span class="hljs-attr">app:barrierMargin</span>=<span class="hljs-string">"@dimen/barrier_margin"</span>
            <span class="hljs-attr">app:constraint_referenced_ids</span>=<span class="hljs-string">"main_lastName_title,main_firstName_title,main_birthDate_title,
        main_nationality_title, main_occupation_title,student_school_name_title,
        student_diploma_year_title,worker_company_title,worker_experience_title,worker_sector_title"</span> /&gt;</span>
</div></code></pre>
<p>A l'intérieur de cette dernière, nous avons rajouté tous les id des <code>TextView</code> qui nous intéressent. Ensuite, nous avons utilisé cette barrière comme référence pour toutes les <code>EditText</code> afin qu'elles soient alignées.</p>
<h3 id="14-materialdatepicker">1.4. MaterialDatePicker</h3>
<p>Nous avons eu le choix entre utiliser <code>DatePickerDialog</code> et <code>MaterialDatePicker</code> afin de choisir une date. Nous avons choisi d'utiliser <code>MaterialDatePicker</code> car il est plus moderne. Pour le détails d'implémentations, voir la question 2.3.</p>
<h3 id="15-ouverture-du-datepicker">1.5. Ouverture du DatePicker</h3>
<p>Nous avons gérer l'ouverture du <code>DatePicker</code> grace à cette méthode:</p>
<pre class="hljs"><code><div>txtBirthday.setOnFocusChangeListener { _, hasFocus -&gt;
    <span class="hljs-keyword">if</span> (hasFocus) {
        showDatePicker()
    }
}
txtBirthday.keyListener = <span class="hljs-literal">null</span> <span class="hljs-comment">// Désactive le clavier</span>
</div></code></pre>
<h3 id="16-bouton-okcancel">1.6. Bouton ok/cancel</h3>
<p>Les listeners sont définis comme suit:</p>
<pre class="hljs"><code><div>btnSubmit.setOnClickListener {
    createPerson()
}

btnReset.setOnClickListener {
    resetFields()
}
</div></code></pre>
<p>La méthode <code>resetFields()</code> permet de clear tous les <code>EditText</code> et <code>RadioGroup</code> et de remettre les séléctions des <code>Spinner</code> à zéro.</p>
<h3 id="17-cr%C3%A9ation-dune-personne">1.7. Création d'une personne</h3>
<p>Lors de la soumission du formulaire, nous vérifions en premier lieu que tous les champs en commun soient remplis, à l'exception du champ commentaire. Si ce n'est pas le cas, un message d'erreur s'affiche à l'aide d'un <code>Toast</code>. Nous vérifions ensuite que le champ email contienne bien un email valide grâce à une Regex fournie par Android.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (!Patterns.EMAIL_ADDRESS.matcher(email).matches()) {
    showError(resources.getString(R.string.error_invalid_email))
    <span class="hljs-keyword">return</span>
}
</div></code></pre>
<p>Ensuite la personne est créée en fonction de son type (étudiant ou employé):</p>
<pre class="hljs"><code><div><span class="hljs-keyword">when</span> (radGroup.checkedRadioButtonId) {
    R.id.main_occupation_student -&gt; {
        <span class="hljs-comment">// Création d'un étudiant</span>
    }
    R.id.main_occupation_worker -&gt; {
        <span class="hljs-comment">// Création d'un employé</span>
    }
    <span class="hljs-keyword">else</span> -&gt; {
        showError(resources.getString(R.string.error_undefined_occupation))
        <span class="hljs-keyword">return</span>
    }
}
Log.println(Log.INFO, <span class="hljs-string">"Person"</span>, person.toString())
Toast.makeText(<span class="hljs-keyword">this</span>, getString(R.string.user_created), Toast.LENGTH_LONG).show()
resetFields()
</div></code></pre>
<p>Les champs spécifiques à un étudiant ou un employé sont vérifiés dans le when. Si un champ n'est pas rempli, un message d'erreur s'affiche à l'aide d'un <code>Toast</code>.</p>
<p>Voici l'implémentations de la fonction <code>showError</code></p>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showError</span><span class="hljs-params">(message: <span class="hljs-type">String</span>)</span></span> {
    Toast.makeText(<span class="hljs-keyword">this</span>, message, Toast.LENGTH_SHORT).show()
}
</div></code></pre>
<h3 id="18-charger-une-personne-existante">1.8. Charger une personne existante</h3>
<p>La méthode suivante, qui est publique, permet de load une personne existante et d'afficher ses informations dans le formulaire:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadPerson</span><span class="hljs-params">(person: <span class="hljs-type">Person</span>)</span></span> {
    txtLastName.setText(person.name)
    txtFirstName.setText(person.firstName)

    <span class="hljs-keyword">val</span> formattedDate = dateFormatter.format(
        LocalDateTime.ofInstant(
            person.birthDay.toInstant(),
            ZoneId.systemDefault()
        )
    )
    txtBirthday.setText(formattedDate)

    <span class="hljs-keyword">val</span> nationalityPosition = nationalityAdapter.getPosition(person.nationality)
    spnNationality.setSelection(nationalityPosition)

    txtEmail.setText(person.email)
    txtRemark.setText(person.remark)

    <span class="hljs-keyword">when</span> (person) {
        <span class="hljs-keyword">is</span> Student -&gt; {
            radStudent.isChecked = <span class="hljs-literal">true</span>
            txtUniversity.setText(person.university)
            txtGraduationYear.setText(person.graduationYear.toString())
        }
        <span class="hljs-keyword">is</span> Worker -&gt; {
            radWorker.isChecked = <span class="hljs-literal">true</span>
            txtCompany.setText(person.company)

            <span class="hljs-keyword">val</span> sectorPosition = sectorAdapter.getPosition(person.sector)
            spnSector.setSelection(sectorPosition)

            txtExperienceYear.setText(person.experienceYear.toString())
        }
    }
}
</div></code></pre>
<h2 id="2-question-compl%C3%A9mentaire">2. Question complémentaire</h2>
<h3 id="21">2.1</h3>
<p><strong>Pour le champ remark, destiné à accueillir un texte pouvant être plus long qu’une seule ligne, quelle configuration particulière faut-il faire dans le fichier XML pour que son comportement soit correct ? Nous pensons notamment à la possibilité de faire des retours à la ligne, d’activer le correcteur orthographique et de permettre au champ de prendre la taille nécessaire.</strong></p>
<p>Voici la balise <code>EditText</code> dans laquelle on peut voir l'attribut <code>android:inputType</code> qui permet d'activer le correcteur orthographique et le mode multilignes.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">EditText</span>
    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/additional_remarks_editText"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"0dp"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:autofillHints</span>=<span class="hljs-string">"remarks"</span>
    <span class="hljs-attr">android:inputType</span>=<span class="hljs-string">"text|textMultiLine|textCapSentences|textAutoCorrect"</span>
    <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">"parent"</span>
    <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">"parent"</span>
    <span class="hljs-attr">app:layout_constraintTop_toBottomOf</span>=<span class="hljs-string">"@id/additional_remarks_title"</span> /&gt;</span>
</div></code></pre>
<h3 id="22">2.2</h3>
<p><strong>Pour afficher la date sélectionnée via le DatePicker nous pouvons utiliser un DateFormat permettant par exemple d’afficher 12 juin 1996 à partir d’une instance de Date. Le formatage des dates peut être relativement différent en fonction des langues, la traduction des mois par exemple, mais également des habitudes régionales différentes : la même date en anglais britannique serait 12th June 1996 et en anglais américain June 12, 1996. Comment peut-on gérer cela au mieux ?</strong></p>
<p>Pour gérer cela au mieux, il est recommandé d'utiliser les classes <code>DateTimeFormatter</code> et <code>LocalDate</code>. Un formateur localisé peut être obtenu via la méthode <code>DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM)</code> qui permet de prendre en compte le format actuel du système.</p>
<p>Cette ligne permet de parser une date depuis une chaîne de caractère:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// dateFormatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM)</span>
<span class="hljs-keyword">val</span> date = LocalDate.parse(txtBirthday.text, dateFormatter)
</div></code></pre>
<h2 id="23">2.3</h2>
<p><strong>Est-il possible de limiter les dates sélectionnables dans le dialogue, en particulier pour une date de naissance il est peu probable d’avoir une personne née il y a plus de 110 ans ou à une date dans le futur. Comment pouvons-nous mettre cela en place ?</strong></p>
<p>Oui c'est possible.
Voici l'implémentation de notre date picker:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showDatePicker</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> selectedDate = Calendar.getInstance()
    <span class="hljs-keyword">if</span> (txtBirthday.text.isNotEmpty()) {
        <span class="hljs-keyword">val</span> date = LocalDate.parse(txtBirthday.text, dateFormatter)
        selectedDate.<span class="hljs-keyword">set</span>(date.year, date.monthValue - <span class="hljs-number">1</span>, date.dayOfMonth)
    }

    <span class="hljs-comment">// Calcule de l'année minimale en utilisant l'année courante</span>
    <span class="hljs-keyword">val</span> minDateInMs =
        OffsetDateTime.now(ZoneOffset.UTC).minusYears(DATEPICKER_RELATIVE_LOWER_YEAR)
            .toInstant().toEpochMilli()

    <span class="hljs-comment">// Définition des validateurs de date pour désactiver les dates invalides</span>
    <span class="hljs-keyword">val</span> calendarValidators = CompositeDateValidator.allOf(
        listOf(
            DateValidatorPointBackward.now(), <span class="hljs-comment">// pas de date dans le futur</span>
            DateValidatorPointForward.from(minDateInMs)
        )
    )

    <span class="hljs-keyword">val</span> calendarConstraints = CalendarConstraints.Builder()
        .setOpenAt(selectedDate.timeInMillis) <span class="hljs-comment">// ouverture du calendrier à la date sélectionnée</span>
        .setEnd(MaterialDatePicker.thisMonthInUtcMilliseconds()) <span class="hljs-comment">// Empêche d'aller sur les mois suivants</span>
        .setValidator(calendarValidators)

    <span class="hljs-keyword">val</span> datePicker = MaterialDatePicker.Builder.datePicker()
        .setCalendarConstraints(calendarConstraints.build())
        .setSelection(selectedDate.timeInMillis)
        .build()

    datePicker.show(supportFragmentManager, <span class="hljs-literal">null</span>)

    datePicker.addOnPositiveButtonClickListener {
        <span class="hljs-comment">// Conversion de la date sélectionnée en string</span>
        <span class="hljs-keyword">val</span> date = LocalDateTime.ofInstant(Instant.ofEpochMilli(it), ZoneOffset.UTC)
        txtBirthday.setText(date.format(dateFormatter))
    }
}
</div></code></pre>
<p>Comme indiqué dans la documentation du <code>DatePicker</code>, ce dernier ne travaille qu'en UTC. Ce qui nous force à spécifier la timezone à certaines lignes.</p>
<p>Nous faisons deux <code>validators</code> qui permettent de limiter les dates sélectionnables dans le dialogue. Dans notre cas, les dates sont limitées dans l'intervalle [110ans en arrière, aujourd'hui].</p>
<h2 id="24">2.4</h2>
<p><strong>Lors du remplissage des champs textuels, vous pouvez constater que le bouton « suivant » présent sur le clavier virtuel permet de sauter automatiquement au prochain champ à saisir, cf. Fig. 2. Est-ce possible de spécifier son propre ordre de remplissage du questionnaire ? Arrivé sur le dernier champ, est-il possible de faire en sorte que ce bouton soit lié au bouton de validation du questionnaire ?</strong></p>
<p>Oui c'est possible. Pour spécifier son propre ordre de remplissage du questionnaire, il faut ajouter l'attribut <code>android:nextFocusForward</code> et <code>android:imeOptions=&quot;actionNext&quot;</code> sur les champs en questions.</p>
<p>Pour faire en sorte que le bouton « suivant » soit lié au bouton de validation du questionnaire, il faut ajouter l'attribut <code>android:imeOptions=&quot;actionDone&quot;</code> sur le champ en question.</p>
<p>Ensuite, il faut ajouter un listener dans l'activité et simuler un clic du bouton de validation du questionnaire.</p>
<pre class="hljs"><code><div>additional_remarks_editText.setOnEditorActionListener { _, actionId, _ -&gt;
    <span class="hljs-keyword">if</span> (actionId == EditorInfo.IME_ACTION_DONE) {
        ok_button.performClick()
        <span class="hljs-literal">true</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-literal">false</span>
    }
}
</div></code></pre>
<h2 id="25">2.5</h2>
<p><strong>Pour les deux Spinners (nationalité et secteur d’activité), comment peut-on faire en sorte que le premier choix corresponde au choix null, affichant par exemple « Sélectionner » ? Comment peut-on gérer cette valeur pour ne pas qu’elle soit confondue avec une réponse ?</strong></p>
<p>Nous avons fait un adapteur personnalisé qui prend une chaîne de caractère en paramètre. Cette chaîne de caractère est utilisée comme affichage lorsque aucun élément n'est sélectionné.</p>
<p>Pour gérer l'affichage, nous avons réécrit les méthodes suivantes:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getDropDownView</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>, convertView: <span class="hljs-type">View</span>?, parent: <span class="hljs-type">ViewGroup</span>)</span></span>: View {
    <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> View(context).apply {
            visibility = View.GONE
            tag = <span class="hljs-number">1</span> <span class="hljs-comment">// indique que cette vue est un "hint" et qu'il ne faut pas la réutiliser</span>
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (convertView?.tag == <span class="hljs-number">1</span>) { <span class="hljs-comment">// si la vue précédente est un "hint", il faut en créer une nouvelle</span>
        <span class="hljs-keyword">super</span>.getDropDownView(position, <span class="hljs-literal">null</span>, parent)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">super</span>.getDropDownView(position, convertView, parent)
    }
}

<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getView</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>, convertView: <span class="hljs-type">View</span>?, parent: <span class="hljs-type">ViewGroup</span>)</span></span>: View {
    <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> getHintView(parent)
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getView(position, convertView, parent)
}

<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getHintView</span><span class="hljs-params">(parent: <span class="hljs-type">ViewGroup</span>)</span></span>: View {
    <span class="hljs-keyword">val</span> view = inflater.inflate(resource, parent, <span class="hljs-literal">false</span>)

    view.findViewById&lt;TextView&gt;(android.R.id.text1).also {
        it.hint = <span class="hljs-keyword">this</span>.hintText
    }

    <span class="hljs-keyword">return</span> view
}
</div></code></pre>
<p>Et voici comment nous l'utilisons dans le code:</p>
<pre class="hljs"><code><div>sectorAdapter = ArrayAdapterWithDefaultValue(
    <span class="hljs-keyword">this</span>,
    android.R.layout.simple_list_item_1,
    resources.getStringArray(R.array.sectors).toList(),
    resources.getString(R.string.sectors_empty)
)

spnSector.adapter = sectorAdapter

spnSector.onItemSelectedListener = <span class="hljs-keyword">object</span> : AdapterView.OnItemSelectedListener {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onItemSelected</span><span class="hljs-params">(
        parent: <span class="hljs-type">AdapterView</span>&lt;*&gt;?,
        view: <span class="hljs-type">View</span>?,
        position: <span class="hljs-type">Int</span>,
        id: <span class="hljs-type">Long</span>
    )</span></span> {
        selectedSector = sectorAdapter.getItem(position) <span class="hljs-comment">// On garde une référence sur l'élément sélectionné lors d'un changement</span>
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNothingSelected</span><span class="hljs-params">(parent: <span class="hljs-type">AdapterView</span>&lt;*&gt;?)</span></span> {
        selectedSector = <span class="hljs-literal">null</span>
    }
}
</div></code></pre>
<p>Pour ne pas confondre la première valeur avec une réponse, nous avons inséré <code>null</code> au début de la liste des valeurs.</p>
<p>Ces deux lignes permettent de séléctionner le bon élément dans le spinner en fonction de la valeur:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">val</span> nationalityPosition = nationalityAdapter.getPosition(person.nationality)
spnNationality.setSelection(nationalityPosition)
</div></code></pre>

</body>
</html>
